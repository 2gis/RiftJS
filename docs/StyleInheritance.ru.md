# Наследование стилей

При создании модуля можно указать его `blockName` по БЕМ-у:
```js
var UserCard = rt.BaseView.extend('UserCard', {
	blockName: 'dg-UserCard'
});

module.exports = UserCard;
```
Такой модуль будет генерировать следующий html:
```html
<div class="dg-UserCard" ... > ... </div>
```
Если `blockName` не задан, в качестве `blockName`-а будет использовано имя модуля (первый аргумент в `extend`).  
Тут возникает проблема: если мы захотим унаследовать от `UserCard` и также не зададим в наследнике `blockName`, то стили определённые с `blockName`-ом `UserCard` не унаследуются для потомка, т. к. для него будет использован другой `blockName` (опять же имя наследующего модуля). Прийдётся при определении стилей дописывать по два класса:
```css
.UserCard,
.ExtendedUserCard {
	background: black;
	color: white;
}
```
Если положить такое определение стилей в директории модуля `UserCard`, то получиться, что `UserCard` знает о своём потомке, что, конечно, совсем нехорошо, и наоборот, положив такие стили в директории модуля `ExtendedUserCard` получаем ситуацию, когда `UserCard` сам не знает где валяются его стили. Если же всё-таки разложить эти стили по разным файлам, то придётся в `ExtendedUserCard` дублировать даже те значения, которые не переопределяются. Тут конечно можно зарешать препроцессором, но объём генерируемого css-а будет сильно расти.

Разруливается проблема следующим образом:  
модули, напрямую наследующие от `Rift.BaseView`, как и было сказано выше, используют `blockName` созданный из своего имени, а их потомки свой `blockName` не создают, а оставляют унаследованный. При этом программист должен в потомке определить модификатор, описывающий добавленный в потомке функционал. В результате потомок определяется примерно так:
```js
var ExtendedUserCard = require('../UserCard').extend('ExtendedUserCard', {
	mods: {
		extended: true
	}
});

module.exports = ExtendedUserCard;
```
Этот модуль будет генерировать следующий html (`blockName` остался от родителя):
```html
<div class="UserCard _extended" ... > ... </div>
```
Стили `UserCard`-а кладутся в его директорию и не содержат никаких `.ExtendedUserCard`:
```css
.UserCard {
	background: black;
	color: white;
}
```
А в директории модуля `ExtendedUserCard` можно переопределять унаследованные стили с использованием модификатора:
```css
.UserCard._extended {
	color: red;
	font-size: 1.2em;
}
```
При дальнейшем наследовании добавляется больше модификаторов:
```css
.UserCard._extended._more {
	font-size: 1.5em;
}
```
Сильно конечно не стоит увлекаться, т. к. проблема постоянного написания модификаторов в css хоть и разруливается препроцессором, но объём генерируемого css-а всё же может стать большим, чем хотелось бы.

Также при таком подходе не важно в каком порядке сборщик склейт файлы стилей.  
В результате получаем полноценное наследование стилей без каких-то особых усложнений.
